# Plan Tool History & File Tracking Design

## Overview

Add automatic tracking of tool calls and generated files for each step in a Plan.

## Requirements

1. **step_tool_history**: Record which tools were called during each step and their results
2. **step_files**: Track files generated by each step

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Recording mechanism | BaseAgent auto-records | No LLM cooperation needed, complete data |
| Data structure | Compact format | Balance between detail and size |
| Result size limit | 200 chars, truncate | Prevent Plan object bloat |
| File detection | Parse tool args + shell patterns | Cover explicit ops and shell/python writes |

## Data Structures

### Plan New Fields

```python
class Plan:
    # Existing fields...

    # New: tool call history per step
    step_tool_history: dict[int, list[dict]] = {}
    # Format: {step_index: [{tool, args, result, timestamp}, ...]}

    # New: generated files per step
    step_files: dict[int, list[str]] = {}
    # Format: {step_index: ["/workspace/output.txt", ...]}
```

### Tool History Record Format

```python
{
    "tool": "run_python",
    "args": {"code": "print('hello')"},
    "result": "{'exit_code': 0, 'stdout': 'hello\\n'}...[truncated]",
    "timestamp": "2026-01-20T10:30:00"
}
```

- Result truncated at 200 chars with `...[truncated]` suffix
- Timestamp in ISO 8601 format

## Implementation

### Plan Methods

```python
def add_tool_call(self, step_index: int, tool: str, args: dict,
                  result: Any, timestamp: str) -> None:
    """Record a tool call for a step"""

def add_file(self, step_index: int, file_path: str) -> None:
    """Record a generated file for a step"""
```

### BaseAgent Changes

```python
class BaseAgent:
    def __init__(self, ...):
        self._current_step_index: int | None = None
        self._pending_calls: dict[str, dict] = {}  # call_id -> {tool, args, timestamp}

    def _process_event(self, event):
        # Intercept function_call -> store in _pending_calls
        # Intercept function_response -> match with pending, write to plan
        # Extract files -> write to plan.step_files
```

### File Detection

Tracked tools:
- `write_file` - extract `path` from args
- `create_directory` - extract `path` from args
- `run_command` - parse shell redirects (`>`, `>>`)
- `run_python` - parse `open(..., 'w')` patterns

### Display Format

```
Plan: Build Data Pipeline
========================================
Progress: 2/3 (66.7%)

Steps:
  0: [✓] Load CSV data
      Notes: Loaded 1000 rows
      Tools: read_file (1 call)
      Files: -
  1: [✓] Process and save results
      Notes: Saved processed data
      Tools: run_python (1 call)
      Files: /workspace/output.csv
  2: [ ] Generate report (depends on: [1])
```

## Files to Modify

| File | Changes |
|------|---------|
| `app/task/plan.py` | Add `step_tool_history`, `step_files`, methods, update `format()` |
| `app/agents/base/base_agent.py` | Add `_current_step_index`, `_pending_calls`, modify `_process_event` |
| `app/agents/executor/executor_agent.py` | Set `_current_step_index` in `execute_step` |
| `tests/task/test_plan.py` | Add tests for new functionality |

## Files Not Changed

- `ActToolkit` - notes remain LLM-filled
- `PlanToolkit` - no changes needed
- `Cortex` - inherits new functionality automatically
